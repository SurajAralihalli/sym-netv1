from symnet import AbstractModel

from symnet.data_utils import read_data
from keras.callbacks import LearningRateScheduler, ModelCheckpoint
from keras.preprocessing.image import ImageDataGenerator

import pandas as pd
import numpy as np
import os


class AbstractImageClassificationModel(AbstractModel):
    """
    An abstract class meant as a base class for all image classifiers. Concrete
    classes subclassing this should implement specific architectures like ResNet
    or DenseNet. This should not be used directly.

    We assume that the data is provided as a CSV, with a header column (which
    doesn't matter), and that it has 2 columns--the first being the relative
    paths to the images, and the second being the class.
    """

    def __init__(self, path: str, label_column: str = None, header: int = 0, augment_data: bool = True,
                 normalize: bool = True, balance: bool = True, *args, **kwargs):

        super(AbstractImageClassificationModel, self).__init__(path, *args, **kwargs)

        self.label_column = label_column
        self.augment_data = augment_data
        self.normalize = normalize

        x_train, x_test, y_train, y_test = read_data(path, label_column, header, balance, self.train_size,
                                                     categorize=False)

        x_train = x_train.squeeze()
        x_test = x_test.squeeze()

        y_train = np.array(list(map(str, y_train)))
        y_test = np.array(list(map(str, y_test)))

        self.train_df = pd.DataFrame({'filename': x_train, 'class': y_train})
        self.test_df = pd.DataFrame({'filename': x_test, 'class': y_test})

        self.input_shape = (256, 256, 3)  # TODO: Change this if resizing images intelligently.
        self.datagen = None

    def fit(self, finish_fit: bool = True):
        """
        Fits the model. The value of finish_fit here does not matter: it will be forced
        to True.
        :param finish_fit: Useless parameter
        :return: None
        """

        super(AbstractImageClassificationModel, self).fit(False)

        if self.augment_data:
            # Augment the data and call fit() ourselves.
            self.datagen = ImageDataGenerator(
                # set input mean to 0 over the dataset
                featurewise_center=False,
                # set each sample mean to 0
                samplewise_center=False,
                # divide inputs by std of dataset
                featurewise_std_normalization=False,
                # divide each input by its std
                samplewise_std_normalization=False,
                # apply ZCA whitening
                zca_whitening=False,
                # epsilon for ZCA whitening
                zca_epsilon=1e-06,
                # randomly rotate images in the range (deg 0 to 180)
                rotation_range=0,
                # randomly shift images horizontally
                width_shift_range=0.1,
                # randomly shift images vertically
                height_shift_range=0.1,
                # set range for random shear
                shear_range=0.,
                # set range for random zoom
                zoom_range=0.,
                # set range for random channel shifts
                channel_shift_range=0.,
                # set mode for filling points outside the input boundaries
                fill_mode='nearest',
                # value used for fill_mode = "constant"
                cval=0.,
                # randomly flip images
                horizontal_flip=True,
                # randomly flip images
                vertical_flip=False,
                # set rescaling factor (applied before any other transformation)
                rescale=None,
                # set function that will be applied on each input
                preprocessing_function=None,
                # image data format, either "channels_first" or "channels_last"
                data_format=None,
                # fraction of images reserved for validation (strictly between 0 and 1)
                validation_split=0.0)
        else:
            self.datagen = ImageDataGenerator()

        lr_scheduler = LearningRateScheduler(self._lr_schedule)
        # Prepare callbacks for model saving and for learning rate adjustment.
        save_dir = os.path.join(os.getcwd(), 'saved_models')
        model_name = 'model.{epoch:03d}.h5'

        # Prepare model model saving directory.
        if not os.path.isdir(save_dir):
            os.makedirs(save_dir)

        filepath = os.path.join(save_dir, model_name)
        checkpoint = ModelCheckpoint(filepath=filepath,
                                     monitor='val_acc',
                                     verbose=1,
                                     save_best_only=True)
        callbacks = [checkpoint]  # TODO: Add LR Scheduler

        # Fit the model on the batches generated by datagen.flow().
        generator = self.datagen.flow_from_dataframe(self.train_df,
                                                     directory=os.getcwd(),
                                                     target_size=(256, 256),  # TODO: Change
                                                     batch_size=self.bs)
        self.model.fit_generator(generator,
                                 steps_per_epoch=len(generator) // self.bs,
                                 epochs=self.epochs,
                                 verbose=1,
                                 workers=4,
                                 callbacks=callbacks)

    def score(self):
        return self.model.evaluate_generator(self.datagen.flow_from_dataframe(self.test_df,
                                                                              directory=os.getcwd(),
                                                                              target_size=(256, 256),  # TODO: Change
                                                                              batch_size=self.bs))
